{"ast":null,"code":"function easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\nvar TIMEOUT_MIN = 50;\nvar TIMEOUT_DEFAULT = 100;\nvar DURATION_DEFAULT = 300;\nvar THRESHOLD_DEFAULT = 0.2;\nvar SNAPSTOP_DEFAULT = false;\nvar EASING_DEFAULT = easeInOutQuad;\n\nvar NOOP = function () {};\n\nvar ScrollSnap =\n/** @class */\nfunction () {\n  function ScrollSnap(element, config) {\n    var _this = this;\n\n    this.animating = false;\n    this.lastScrollValue = {\n      x: 0,\n      y: 0\n    };\n\n    this.startAnimation = function () {\n      _this.speedDeltaX = _this.checkScrollSpeed(_this.target.scrollLeft, 'x');\n      _this.speedDeltaY = _this.checkScrollSpeed(_this.target.scrollTop, 'y');\n\n      if (_this.animating || _this.speedDeltaX === 0 && _this.speedDeltaY === 0) {\n        return;\n      }\n\n      _this.handler(_this.target);\n    };\n\n    this.animationHandler = function () {\n      // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for this.scrollStart+1.\n      if (_this.scrollStart.y === _this.target.scrollTop && _this.scrollStart.x === _this.target.scrollLeft) {\n        // ignore timeout\n        return;\n      } // detect direction of scroll. negative is up, positive is down.\n\n\n      var direction = {\n        y: Math.sign(_this.speedDeltaY),\n        x: Math.sign(_this.speedDeltaX)\n      }; // get the next snap-point to snap-to\n\n      var snapPoint = _this.getNextSnapPoint(_this.target, direction);\n\n      _this.listenerElement.removeEventListener('scroll', _this.startAnimation, false);\n\n      _this.animating = true; // smoothly move to the snap point\n\n      _this.smoothScroll(_this.target, snapPoint, function () {\n        // after moving to the snap point, rebind the scroll event handler\n        _this.animating = false;\n\n        _this.listenerElement.addEventListener('scroll', _this.startAnimation, false);\n\n        _this.onAnimationEnd(); // reset scrollStart\n\n\n        _this.scrollStart = {\n          y: _this.target.scrollTop,\n          x: _this.target.scrollLeft\n        };\n      });\n    };\n\n    this.element = element;\n    var snapDestinationX = config.snapDestinationX,\n        snapDestinationY = config.snapDestinationY,\n        timeout = config.timeout,\n        duration = config.duration,\n        threshold = config.threshold,\n        snapStop = config.snapStop,\n        easing = config.easing;\n\n    if (snapDestinationX && typeof snapDestinationX !== 'string' && typeof snapDestinationX !== 'number') {\n      throw new Error(\"Config property 'snapDestinationX' is not valid, expected STRING or NUMBER but found \" + (typeof snapDestinationX).toUpperCase());\n    }\n\n    this.snapDestinationX = snapDestinationX;\n\n    if (snapDestinationY && typeof snapDestinationY !== 'string' && typeof snapDestinationY !== 'number') {\n      throw new Error(\"Config property 'snapDestinationY' is not valid, expected STRING or NUMBER but found \" + (typeof snapDestinationY).toUpperCase());\n    }\n\n    this.snapDestinationY = snapDestinationY;\n\n    if (timeout && (isNaN(timeout) || typeof timeout === 'boolean')) {\n      throw new Error(\"Optional config property 'timeout' is not valid, expected NUMBER but found \" + (typeof timeout).toUpperCase());\n    } // any value less then TIMEOUT_MIN may cause weird bahaviour on some devices (especially on mobile with momentum scrolling)\n\n\n    this.timeout = timeout && timeout >= TIMEOUT_MIN ? timeout : TIMEOUT_DEFAULT;\n\n    if (duration && (isNaN(duration) || typeof duration === 'boolean')) {\n      throw new Error(\"Optional config property 'duration' is not valid, expected NUMBER but found \" + (typeof duration).toUpperCase());\n    }\n\n    this.duration = duration || DURATION_DEFAULT;\n\n    if (threshold && (isNaN(threshold) || typeof threshold === 'boolean')) {\n      throw new Error(\"Optional config property 'threshold' is not valid, expected NUMBER but found \" + (typeof threshold).toUpperCase());\n    }\n\n    this.threshold = threshold || THRESHOLD_DEFAULT;\n\n    if (easing && typeof easing !== 'function') {\n      throw new Error(\"Optional config property 'easing' is not valid, expected FUNCTION but found \" + (typeof easing).toUpperCase());\n    }\n\n    this.easing = easing || EASING_DEFAULT;\n\n    if (snapStop && typeof snapStop !== 'boolean') {\n      throw new Error(\"Optional config property 'snapStop' is not valid, expected BOOLEAN but found \" + (typeof snapStop).toUpperCase());\n    }\n\n    this.snapStop = snapStop || SNAPSTOP_DEFAULT;\n  }\n\n  ScrollSnap.prototype.checkScrollSpeed = function (value, axis) {\n    var _this = this;\n\n    var clear = function () {\n      _this.lastScrollValue[axis] = null;\n    };\n\n    var newValue = value;\n    var delta;\n\n    if (this.lastScrollValue[axis] !== null) {\n      delta = newValue - this.lastScrollValue[axis];\n    } else {\n      delta = 0;\n    }\n\n    this.lastScrollValue[axis] = newValue;\n    this.scrollSpeedTimer && clearTimeout(this.scrollSpeedTimer);\n    this.scrollSpeedTimer = window.setTimeout(clear, 100);\n    return delta;\n  };\n\n  ScrollSnap.prototype.saveDeclaration = function (obj) {\n    this.snapLengthUnit = this.parseSnapCoordValue(this.snapDestinationX, this.snapDestinationY);\n  };\n\n  ScrollSnap.prototype.bindElement = function (element) {\n    this.target = element;\n    this.listenerElement = element === document.documentElement ? window : element;\n    this.listenerElement.addEventListener('scroll', this.startAnimation, false);\n    this.saveDeclaration(this.target);\n  };\n\n  ScrollSnap.prototype.unbindElement = function () {\n    this.listenerElement.removeEventListener('scroll', this.startAnimation, false);\n  };\n  /**\n   * scroll handler\n   * this is the callback for scroll events.\n   */\n\n\n  ScrollSnap.prototype.handler = function (target) {\n    // if currently animating, stop it. this prevents flickering.\n    if (this.animationFrame) {\n      clearTimeout(this.animationFrame);\n    } // if a previous timeout exists, clear it.\n\n\n    if (this.scrollHandlerTimer) {\n      // we only want to call a timeout once after scrolling..\n      clearTimeout(this.scrollHandlerTimer);\n    } else {\n      this.scrollStart = {\n        y: target.scrollTop,\n        x: target.scrollLeft\n      };\n    }\n\n    this.scrollHandlerTimer = window.setTimeout(this.animationHandler, this.timeout);\n  };\n\n  ScrollSnap.prototype.getNextSnapPoint = function (target, direction) {\n    // get snap length\n    var snapLength = {\n      y: Math.round(this.getYSnapLength(this.target, this.snapLengthUnit.y)),\n      x: Math.round(this.getXSnapLength(this.target, this.snapLengthUnit.x))\n    };\n    var top = this.target.scrollTop;\n    var left = this.target.scrollLeft;\n    var startPoint = {\n      y: this.scrollStart.y / snapLength.y || 0,\n      x: this.scrollStart.x / snapLength.x || 0\n    };\n    var currentPoint = {\n      y: top / snapLength.y || 0,\n      x: left / snapLength.x || 0\n    };\n    var nextPoint = {\n      y: 0,\n      x: 0\n    };\n    /**\n     * Set target and bounds by direction,\n     * if threshold has not been reached, scroll back to currentPoint\n     **/\n\n    if (this.isAboveThreshold(direction.y, currentPoint.y)) {\n      if (this.snapStop) {\n        nextPoint.y = this.roundByDirection(-direction.y, startPoint.y + direction.y);\n      } else {\n        nextPoint.y = this.roundByDirection(direction.y, currentPoint.y);\n      }\n    } else {\n      nextPoint.y = this.roundByDirection(direction.y * -1, currentPoint.y);\n    }\n\n    if (this.isAboveThreshold(direction.x, currentPoint.x)) {\n      if (this.snapStop) {\n        nextPoint.x = this.roundByDirection(-direction.x, startPoint.x + direction.x);\n      } else {\n        nextPoint.x = this.roundByDirection(direction.x, currentPoint.x);\n      }\n    } else {\n      nextPoint.x = this.roundByDirection(direction.x * -1, currentPoint.x);\n    } // DEBUG\n    // console.log('direction', direction)\n    // console.log('startPoint', startPoint)\n    // console.log('currentPoint', currentPoint)\n    // console.log('nextPoint', nextPoint)\n    // calculate where to scroll\n\n\n    var scrollTo = {\n      y: nextPoint.y * snapLength.y,\n      x: nextPoint.x * snapLength.x\n    }; // stay in bounds (minimum: 0, maxmimum: absolute height)\n\n    scrollTo.y = this.stayInBounds(0, target.scrollHeight, scrollTo.y);\n    scrollTo.x = this.stayInBounds(0, target.scrollWidth, scrollTo.x);\n    return scrollTo;\n  };\n\n  ScrollSnap.prototype.isAboveThreshold = function (direction, value) {\n    return direction > 0 ? value % 1 > this.threshold : 1 - value % 1 > this.threshold;\n  };\n\n  ScrollSnap.prototype.roundByDirection = function (direction, value) {\n    if (direction === -1) {\n      // when we go up, we floor the number to jump to the next snap-point in scroll direction\n      return Math.floor(value);\n    } // go down, we ceil the number to jump to the next in view.\n\n\n    return Math.ceil(value);\n  };\n\n  ScrollSnap.prototype.stayInBounds = function (min, max, destined) {\n    return Math.max(Math.min(destined, max), min);\n  };\n\n  ScrollSnap.prototype.parseSnapCoordValue = function (x, y) {\n    // regex to parse lengths\n    var regex = /([+-]?(?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*)(?:[eE][+-]?\\d+)?)(px|%|vw|vh)/; // defaults\n\n    var parsed = {\n      y: {\n        value: 0,\n        unit: 'px'\n      },\n      x: {\n        value: 0,\n        unit: 'px'\n      }\n    };\n\n    if (typeof y === 'number') {\n      parsed.y.value = y;\n    } else {\n      var resultY = regex.exec(y);\n\n      if (resultY !== null) {\n        parsed.y = {\n          value: Number(resultY[1]),\n          unit: resultY[2]\n        };\n      }\n    }\n\n    if (typeof x === 'number') {\n      parsed.x.value = x;\n    } else {\n      var resultX = regex.exec(x);\n\n      if (resultX !== null) {\n        parsed.x = {\n          value: Number(resultX[1]),\n          unit: resultX[2]\n        };\n      }\n    }\n\n    return parsed;\n  };\n\n  ScrollSnap.prototype.getYSnapLength = function (obj, declaration) {\n    // get y snap length based on declaration unit\n    if (declaration.unit === 'vh') {\n      return Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100 * declaration.value;\n    } else if (declaration.unit === '%') {\n      return obj.clientHeight / 100 * declaration.value;\n    } else {\n      return declaration.value;\n    }\n  };\n\n  ScrollSnap.prototype.getXSnapLength = function (obj, declaration) {\n    // get x snap length based on declaration unit\n    if (declaration.unit === 'vw') {\n      return Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100 * declaration.value;\n    } else if (declaration.unit === '%') {\n      return obj.clientWidth / 100 * declaration.value;\n    } else {\n      return declaration.value;\n    }\n  };\n\n  ScrollSnap.prototype.isEdge = function (coords) {\n    return coords.x === 0 && this.speedDeltaY === 0 || coords.y === 0 && this.speedDeltaX === 0;\n  };\n\n  ScrollSnap.prototype.smoothScroll = function (obj, end, callback) {\n    var _this = this;\n\n    var position = function (start, end, elapsed, duration) {\n      if (elapsed > duration) {\n        return end;\n      }\n\n      return start + (end - start) * _this.easing(elapsed / duration);\n    };\n\n    var start = {\n      y: obj.scrollTop,\n      x: obj.scrollLeft\n    }; // get animation frame or a fallback\n\n    var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {\n      return window.setTimeout(fn, 15);\n    };\n\n    var duration = this.isEdge(start) ? 1 : this.duration;\n    var startTime; // setup the stepping function\n\n    function step(timestamp) {\n      if (!startTime) {\n        startTime = timestamp;\n      }\n\n      var elapsed = timestamp - startTime; // change position on y-axis if result is a number.\n\n      if (!isNaN(end.y)) {\n        obj.scrollTop = position(start.y, end.y, elapsed, duration);\n      } // change position on x-axis if result is a number.\n\n\n      if (!isNaN(end.x)) {\n        obj.scrollLeft = position(start.x, end.x, elapsed, duration);\n      } // check if we are over due;\n\n\n      if (elapsed < duration) {\n        requestAnimationFrame(step);\n      } else {\n        // is there a callback?\n        if (typeof callback === 'function') {\n          // stop execution and run the callback\n          return callback(end);\n        }\n      }\n    }\n\n    this.animationFrame = requestAnimationFrame(step);\n  };\n\n  ScrollSnap.prototype.bind = function (callback) {\n    this.onAnimationEnd = typeof callback === 'function' ? callback : NOOP;\n    this.bindElement(this.element);\n    return this;\n  };\n\n  ScrollSnap.prototype.unbind = function () {\n    this.unbindElement();\n    return this;\n  };\n\n  return ScrollSnap;\n}();\n\nexport default ScrollSnap;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\nvar TIMEOUT_MIN = 50;\nvar TIMEOUT_DEFAULT = 100;\nvar DURATION_DEFAULT = 300;\nvar THRESHOLD_DEFAULT = 0.2;\nvar SNAPSTOP_DEFAULT = false;\nvar EASING_DEFAULT = easeInOutQuad;\nvar NOOP = function () { };\nvar ScrollSnap = /** @class */ (function () {\n    function ScrollSnap(element, config) {\n        var _this = this;\n        this.animating = false;\n        this.lastScrollValue = {\n            x: 0,\n            y: 0,\n        };\n        this.startAnimation = function () {\n            _this.speedDeltaX = _this.checkScrollSpeed(_this.target.scrollLeft, 'x');\n            _this.speedDeltaY = _this.checkScrollSpeed(_this.target.scrollTop, 'y');\n            if (_this.animating || (_this.speedDeltaX === 0 && _this.speedDeltaY === 0)) {\n                return;\n            }\n            _this.handler(_this.target);\n        };\n        this.animationHandler = function () {\n            // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for this.scrollStart+1.\n            if (_this.scrollStart.y === _this.target.scrollTop &&\n                _this.scrollStart.x === _this.target.scrollLeft) {\n                // ignore timeout\n                return;\n            }\n            // detect direction of scroll. negative is up, positive is down.\n            var direction = {\n                y: Math.sign(_this.speedDeltaY),\n                x: Math.sign(_this.speedDeltaX),\n            };\n            // get the next snap-point to snap-to\n            var snapPoint = _this.getNextSnapPoint(_this.target, direction);\n            _this.listenerElement.removeEventListener('scroll', _this.startAnimation, false);\n            _this.animating = true;\n            // smoothly move to the snap point\n            _this.smoothScroll(_this.target, snapPoint, function () {\n                // after moving to the snap point, rebind the scroll event handler\n                _this.animating = false;\n                _this.listenerElement.addEventListener('scroll', _this.startAnimation, false);\n                _this.onAnimationEnd();\n                // reset scrollStart\n                _this.scrollStart = {\n                    y: _this.target.scrollTop,\n                    x: _this.target.scrollLeft,\n                };\n            });\n        };\n        this.element = element;\n        var snapDestinationX = config.snapDestinationX, snapDestinationY = config.snapDestinationY, timeout = config.timeout, duration = config.duration, threshold = config.threshold, snapStop = config.snapStop, easing = config.easing;\n        if (snapDestinationX &&\n            typeof snapDestinationX !== 'string' &&\n            typeof snapDestinationX !== 'number') {\n            throw new Error(\"Config property 'snapDestinationX' is not valid, expected STRING or NUMBER but found \" + (typeof snapDestinationX).toUpperCase());\n        }\n        this.snapDestinationX = snapDestinationX;\n        if (snapDestinationY &&\n            typeof snapDestinationY !== 'string' &&\n            typeof snapDestinationY !== 'number') {\n            throw new Error(\"Config property 'snapDestinationY' is not valid, expected STRING or NUMBER but found \" + (typeof snapDestinationY).toUpperCase());\n        }\n        this.snapDestinationY = snapDestinationY;\n        if (timeout && (isNaN(timeout) || typeof timeout === 'boolean')) {\n            throw new Error(\"Optional config property 'timeout' is not valid, expected NUMBER but found \" + (typeof timeout).toUpperCase());\n        }\n        // any value less then TIMEOUT_MIN may cause weird bahaviour on some devices (especially on mobile with momentum scrolling)\n        this.timeout = timeout && timeout >= TIMEOUT_MIN ? timeout : TIMEOUT_DEFAULT;\n        if (duration && (isNaN(duration) || typeof duration === 'boolean')) {\n            throw new Error(\"Optional config property 'duration' is not valid, expected NUMBER but found \" + (typeof duration).toUpperCase());\n        }\n        this.duration = duration || DURATION_DEFAULT;\n        if (threshold && (isNaN(threshold) || typeof threshold === 'boolean')) {\n            throw new Error(\"Optional config property 'threshold' is not valid, expected NUMBER but found \" + (typeof threshold).toUpperCase());\n        }\n        this.threshold = threshold || THRESHOLD_DEFAULT;\n        if (easing && typeof easing !== 'function') {\n            throw new Error(\"Optional config property 'easing' is not valid, expected FUNCTION but found \" + (typeof easing).toUpperCase());\n        }\n        this.easing = easing || EASING_DEFAULT;\n        if (snapStop && typeof snapStop !== 'boolean') {\n            throw new Error(\"Optional config property 'snapStop' is not valid, expected BOOLEAN but found \" + (typeof snapStop).toUpperCase());\n        }\n        this.snapStop = snapStop || SNAPSTOP_DEFAULT;\n    }\n    ScrollSnap.prototype.checkScrollSpeed = function (value, axis) {\n        var _this = this;\n        var clear = function () {\n            _this.lastScrollValue[axis] = null;\n        };\n        var newValue = value;\n        var delta;\n        if (this.lastScrollValue[axis] !== null) {\n            delta = newValue - this.lastScrollValue[axis];\n        }\n        else {\n            delta = 0;\n        }\n        this.lastScrollValue[axis] = newValue;\n        this.scrollSpeedTimer && clearTimeout(this.scrollSpeedTimer);\n        this.scrollSpeedTimer = window.setTimeout(clear, 100);\n        return delta;\n    };\n    ScrollSnap.prototype.saveDeclaration = function (obj) {\n        this.snapLengthUnit = this.parseSnapCoordValue(this.snapDestinationX, this.snapDestinationY);\n    };\n    ScrollSnap.prototype.bindElement = function (element) {\n        this.target = element;\n        this.listenerElement = element === document.documentElement ? window : element;\n        this.listenerElement.addEventListener('scroll', this.startAnimation, false);\n        this.saveDeclaration(this.target);\n    };\n    ScrollSnap.prototype.unbindElement = function () {\n        this.listenerElement.removeEventListener('scroll', this.startAnimation, false);\n    };\n    /**\n     * scroll handler\n     * this is the callback for scroll events.\n     */\n    ScrollSnap.prototype.handler = function (target) {\n        // if currently animating, stop it. this prevents flickering.\n        if (this.animationFrame) {\n            clearTimeout(this.animationFrame);\n        }\n        // if a previous timeout exists, clear it.\n        if (this.scrollHandlerTimer) {\n            // we only want to call a timeout once after scrolling..\n            clearTimeout(this.scrollHandlerTimer);\n        }\n        else {\n            this.scrollStart = {\n                y: target.scrollTop,\n                x: target.scrollLeft,\n            };\n        }\n        this.scrollHandlerTimer = window.setTimeout(this.animationHandler, this.timeout);\n    };\n    ScrollSnap.prototype.getNextSnapPoint = function (target, direction) {\n        // get snap length\n        var snapLength = {\n            y: Math.round(this.getYSnapLength(this.target, this.snapLengthUnit.y)),\n            x: Math.round(this.getXSnapLength(this.target, this.snapLengthUnit.x)),\n        };\n        var top = this.target.scrollTop;\n        var left = this.target.scrollLeft;\n        var startPoint = {\n            y: this.scrollStart.y / snapLength.y || 0,\n            x: this.scrollStart.x / snapLength.x || 0,\n        };\n        var currentPoint = {\n            y: top / snapLength.y || 0,\n            x: left / snapLength.x || 0,\n        };\n        var nextPoint = {\n            y: 0,\n            x: 0,\n        };\n        /**\n         * Set target and bounds by direction,\n         * if threshold has not been reached, scroll back to currentPoint\n         **/\n        if (this.isAboveThreshold(direction.y, currentPoint.y)) {\n            if (this.snapStop) {\n                nextPoint.y = this.roundByDirection(-direction.y, startPoint.y + direction.y);\n            }\n            else {\n                nextPoint.y = this.roundByDirection(direction.y, currentPoint.y);\n            }\n        }\n        else {\n            nextPoint.y = this.roundByDirection(direction.y * -1, currentPoint.y);\n        }\n        if (this.isAboveThreshold(direction.x, currentPoint.x)) {\n            if (this.snapStop) {\n                nextPoint.x = this.roundByDirection(-direction.x, startPoint.x + direction.x);\n            }\n            else {\n                nextPoint.x = this.roundByDirection(direction.x, currentPoint.x);\n            }\n        }\n        else {\n            nextPoint.x = this.roundByDirection(direction.x * -1, currentPoint.x);\n        }\n        // DEBUG\n        // console.log('direction', direction)\n        // console.log('startPoint', startPoint)\n        // console.log('currentPoint', currentPoint)\n        // console.log('nextPoint', nextPoint)\n        // calculate where to scroll\n        var scrollTo = {\n            y: nextPoint.y * snapLength.y,\n            x: nextPoint.x * snapLength.x,\n        };\n        // stay in bounds (minimum: 0, maxmimum: absolute height)\n        scrollTo.y = this.stayInBounds(0, target.scrollHeight, scrollTo.y);\n        scrollTo.x = this.stayInBounds(0, target.scrollWidth, scrollTo.x);\n        return scrollTo;\n    };\n    ScrollSnap.prototype.isAboveThreshold = function (direction, value) {\n        return direction > 0 ? value % 1 > this.threshold : 1 - (value % 1) > this.threshold;\n    };\n    ScrollSnap.prototype.roundByDirection = function (direction, value) {\n        if (direction === -1) {\n            // when we go up, we floor the number to jump to the next snap-point in scroll direction\n            return Math.floor(value);\n        }\n        // go down, we ceil the number to jump to the next in view.\n        return Math.ceil(value);\n    };\n    ScrollSnap.prototype.stayInBounds = function (min, max, destined) {\n        return Math.max(Math.min(destined, max), min);\n    };\n    ScrollSnap.prototype.parseSnapCoordValue = function (x, y) {\n        // regex to parse lengths\n        var regex = /([+-]?(?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*)(?:[eE][+-]?\\d+)?)(px|%|vw|vh)/;\n        // defaults\n        var parsed = {\n            y: {\n                value: 0,\n                unit: 'px',\n            },\n            x: {\n                value: 0,\n                unit: 'px',\n            },\n        };\n        if (typeof y === 'number') {\n            parsed.y.value = y;\n        }\n        else {\n            var resultY = regex.exec(y);\n            if (resultY !== null) {\n                parsed.y = {\n                    value: Number(resultY[1]),\n                    unit: resultY[2],\n                };\n            }\n        }\n        if (typeof x === 'number') {\n            parsed.x.value = x;\n        }\n        else {\n            var resultX = regex.exec(x);\n            if (resultX !== null) {\n                parsed.x = {\n                    value: Number(resultX[1]),\n                    unit: resultX[2],\n                };\n            }\n        }\n        return parsed;\n    };\n    ScrollSnap.prototype.getYSnapLength = function (obj, declaration) {\n        // get y snap length based on declaration unit\n        if (declaration.unit === 'vh') {\n            return ((Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            return (obj.clientHeight / 100) * declaration.value;\n        }\n        else {\n            return declaration.value;\n        }\n    };\n    ScrollSnap.prototype.getXSnapLength = function (obj, declaration) {\n        // get x snap length based on declaration unit\n        if (declaration.unit === 'vw') {\n            return ((Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            return (obj.clientWidth / 100) * declaration.value;\n        }\n        else {\n            return declaration.value;\n        }\n    };\n    ScrollSnap.prototype.isEdge = function (coords) {\n        return (coords.x === 0 && this.speedDeltaY === 0) || (coords.y === 0 && this.speedDeltaX === 0);\n    };\n    ScrollSnap.prototype.smoothScroll = function (obj, end, callback) {\n        var _this = this;\n        var position = function (start, end, elapsed, duration) {\n            if (elapsed > duration) {\n                return end;\n            }\n            return start + (end - start) * _this.easing(elapsed / duration);\n        };\n        var start = {\n            y: obj.scrollTop,\n            x: obj.scrollLeft,\n        };\n        // get animation frame or a fallback\n        var requestAnimationFrame = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            function (fn) {\n                return window.setTimeout(fn, 15);\n            };\n        var duration = this.isEdge(start) ? 1 : this.duration;\n        var startTime;\n        // setup the stepping function\n        function step(timestamp) {\n            if (!startTime) {\n                startTime = timestamp;\n            }\n            var elapsed = timestamp - startTime;\n            // change position on y-axis if result is a number.\n            if (!isNaN(end.y)) {\n                obj.scrollTop = position(start.y, end.y, elapsed, duration);\n            }\n            // change position on x-axis if result is a number.\n            if (!isNaN(end.x)) {\n                obj.scrollLeft = position(start.x, end.x, elapsed, duration);\n            }\n            // check if we are over due;\n            if (elapsed < duration) {\n                requestAnimationFrame(step);\n            }\n            else {\n                // is there a callback?\n                if (typeof callback === 'function') {\n                    // stop execution and run the callback\n                    return callback(end);\n                }\n            }\n        }\n        this.animationFrame = requestAnimationFrame(step);\n    };\n    ScrollSnap.prototype.bind = function (callback) {\n        this.onAnimationEnd = typeof callback === 'function' ? callback : NOOP;\n        this.bindElement(this.element);\n        return this;\n    };\n    ScrollSnap.prototype.unbind = function () {\n        this.unbindElement();\n        return this;\n    };\n    return ScrollSnap;\n}());\nexport default ScrollSnap;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}